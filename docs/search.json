[{"path":"/articles/introduction.html","id":"basic-example","dir":"Articles","previous_headings":"","what":"Basic Example","title":"Introduction to Redistribution","text":"Say 1 set 5 regions:","code":"regions <- data.frame(id = 1:5) regions #>   id #> 1  1 #> 2  2 #> 3  3 #> 4  4 #> 5  5"},{"path":"/articles/introduction.html","id":"disaggregate","dir":"Articles","previous_headings":"Basic Example","what":"Disaggregate","title":"Introduction to Redistribution","text":"single observation entire set, disaggregate regions. additional information, best guess value region proportional split – case, one fifth observed value region: , maybe know little regions, size; use information adjust proportion allotted region:","code":"# install if needed: remotes::install_github(\"uva-bi-sdad/redistribute\") library(redistribute)  set_value <- 1 (redistribute(set_value, regions, verbose = TRUE)) #> ℹ source IDs: 1 #> ℹ target IDs: id column of `target` #> ℹ map: all target IDs for single source #> ℹ weights: 1 #> ℹ disaggregating 1 variable: #> • (numb; 1) V1 #>   id  V1 #> 1  1 0.2 #> 2  2 0.2 #> 3  3 0.2 #> 4  4 0.2 #> 5  5 0.2 region_values <- redistribute(   set_value, regions,   weight = c(1, 10, 10, 20, 50), verbose = TRUE ) #> ℹ source IDs: 1 #> ℹ target IDs: id column of `target` #> ℹ map: all target IDs for single source #> ℹ weights: `weight` vector #> ℹ disaggregating 1 variable: #> • (numb; 1) V1 region_values #>   id         V1 #> 1  1 0.01098901 #> 2  2 0.10989011 #> 3  3 0.10989011 #> 4  4 0.21978022 #> 5  5 0.54945055"},{"path":"/articles/introduction.html","id":"aggregate","dir":"Articles","previous_headings":"Basic Example","what":"Aggregate","title":"Introduction to Redistribution","text":"observations regions, aggregate single value set. case, can re-aggregate initially disaggregated, recover original observation:","code":"(redistribute(region_values, verbose = TRUE)) #> ℹ source IDs: id column of `source` #> ℹ target IDs: 1 #> ℹ map: all source IDs to a single target #> ℹ weights: 1 #> ℹ aggregating 1 variable: #> • (numb; 1) V1 #>   id V1 #> 1  1  1"},{"path":"/articles/introduction.html","id":"applied-example","dir":"Articles","previous_headings":"","what":"Applied Example","title":"Introduction to Redistribution","text":"One use case redistribution converting demographics data geographic layers. illustration, can look U.S. Census data Fairfax, Virginia: population information provided Census Block Group level lowest, might want look population within zip codes. try aggregating directly block groups zip codes, involves calculating proportional intersections region polygons: also disaggregate parcel level, point locations, aggregate zipcodes: Now can compare estimated total population different methods provided:","code":"# remotes::install_github(\"uva-bi-sdad/catchment\") library(catchment) library(sf)  # download population and data shapes population <- download_census_population(\"~/Downloads\", \"VA\", 2020)$estimates #> ℹ loading existing Virginia population data population <- population[grepl(\"^51(?:059|600)\", population$GEOID), ] population[, -1] <- vapply(   population[, -1], as.numeric, numeric(nrow(population)) ) rownames(population) <- population$GEOID block_groups <- st_transform(   download_census_shapes(\"~/Downloads\", \"VA\", \"bg\", year = 2020), \"WGS84\" ) block_groups <- block_groups[block_groups$GEOID %in% population$GEOID, ] population <- population[block_groups$GEOID, ] st_geometry(population) <- block_groups$geometry population$Overall <- population$TOTAL.POPULATION_Total  # prepare a map library(leaflet) pal <- colorNumeric(scico::scico(255, palette = \"lajolla\"), population$Overall) map <- leaflet(   population,   options = leafletOptions(attributionControl = FALSE) ) |>   addProviderTiles(\"CartoDB.Positron\") |>   addScaleBar(\"bottomleft\") |>   addControl(\"Total Population\", \"topright\") |>   addLayersControl(     position = \"topleft\", overlayGroups = \"Block Groups\",     baseGroups = c(       \"Zip Codes\", \"Parcels -> Zip Codes\", \"Block Groups -> Zip Codes\",       \"Block Groups -> Parcels -> Zip Codes\"     )   ) |>   addLegend(     \"bottomright\", pal, ~Overall,     title = \"Block Groups\", opacity = 1   ) |>   addPolygons(     fillColor = ~ pal(Overall), fillOpacity = 1, weight = 1,     color = \"#000\", highlightOptions = highlightOptions(color = \"#fff\"),     group = \"Block Groups\", label = ~ paste(       GEOID, \"Population:\", round(Overall, 3)     )   ) # Download shapes if needed zipcode_file <- \"~/Downloads/zipcode_va_fairfax.geojson\" if (!file.exists(zipcode_file)) {   download.file(paste0(     \"https://www.fairfaxcounty.gov/euclid/rest/services/\",     \"IPLS/IPLSMap/MapServer/3/query?\",     'geometry={\"xmin\":-90,\"ymin\":-90,\"xmax\":90,\"ymax\":90,',     '\"spatialReference\":{\"wkid\":4326}}&outFields=*&f=geojson'   ), zipcode_file) } zipcodes <- read_sf(zipcode_file)  # redistribute population data from block groups zipcode_population <- redistribute(   population, zipcodes,   target_id = \"ZIPCODE\", verbose = TRUE ) #> ℹ source IDs: GEOID column of `source` #> ℹ target IDs: ZIPCODE column of `target` #> ℹ map: intersections between geometries #> ℹ weights: 1 #> ℹ aggregating 116 variables: #> • (numb; 116) # Download shapes if needed ## https://data-fairfaxcountygis.opendata.arcgis.com/datasets/current-population parcel_file <- \"~/Downloads/parcel_va_fairfax.geojson\" if (!file.exists(parcel_file)) {   download.file(paste0(     \"https://opendata.arcgis.com/api/v3/datasets/\",     \"314bfe4019754952a715be3a33384d9d_0/\",     \"downloads/data?format=geojson&spatialRefId=4326&where=1=1\"   ), parcel_file) } parcels <- read_sf(parcel_file)  # disaggregate population data from block groups to parcels bg_parcel_population <- redistribute(   population, parcels,   weight = \"CURRE_POPUL\", verbose = TRUE ) #> ℹ source IDs: GEOID column of `source` #> ℹ target IDs: sequence, assuming map from geometries #> ℹ map: intersections between geometries #> ℹ weights: CURRE_POPUL column of `target` #> ℹ some `target_id`s were dropped because they were not present in `map` #> ℹ disaggregating 116 variables: #> • (numb; 116) #> ℹ realigning with original target IDs  # then aggregate from parcels to zip codes bg_parcel_zipcode_population <- redistribute(   bg_parcel_population, zipcodes,   source_id = \"id\", target_id = \"ZIPCODE\", verbose = TRUE ) #> ℹ source IDs: id column of `source` #> ℹ target IDs: ZIPCODE column of `target` #> ℹ map: intersections between geometries #> ℹ weights: 1 #> ℹ some `target_id`s were dropped because they were not present in `map` #> ℹ aggregating 116 variables: #> • (numb; 116) #> ℹ realigning with original target IDs  # since it's provided in this case, we can also just aggregate # up from parcels directly parcel_zipcode_population <- redistribute(   parcels, zipcodes,   source_id = \"PIN\", target_id = \"ZIPCODE\", verbose = TRUE ) #> ℹ source IDs: PIN column of `source` #> ℹ target IDs: ZIPCODE column of `target` #> ℹ map: intersections between geometries #> ℹ weights: 1 #> ℹ some `target_id`s were dropped because they were not present in `map` #> ℹ aggregating 7 variables: #> • (numb; 5) OBJECTID, PARCE_ID, CURRE_POPUL, LOW_ESTIM_POPUL, HIGH_ESTIM_POPUL #> • (char; 2) VALID_FROM, VALID_TO #> ℹ re-converting categorical levels #> ℹ realigning with original target IDs all_values <- c(   zipcodes$POPULATION, zipcode_population$Overall,   bg_parcel_zipcode_population$Overall, parcel_zipcode_population$CURRE_POPUL ) pal_zip <- colorNumeric(scico::scico(255, palette = \"lajolla\"), all_values) map |>   addPolygons(     data = zipcodes,     fillColor = ~ pal_zip(POPULATION), fillOpacity = .8, weight = 1,     color = \"#000\", highlightOptions = highlightOptions(color = \"#fff\"),     group = \"Zip Codes\", label = ~ paste(       ZIPCODE, \"Population:\", round(POPULATION, 3)     )   ) |>   hideGroup(\"Zip Codes\") |>   addPolygons(     data = parcel_zipcode_population,     fillColor = ~ pal_zip(CURRE_POPUL), fillOpacity = .8, weight = 1,     color = \"#000\", highlightOptions = highlightOptions(color = \"#fff\"),     group = \"Parcels -> Zip Codes\", label = ~ paste(       id, \"Population:\", round(CURRE_POPUL, 3)     )   ) |>   hideGroup(\"Parcels -> Zip Codes\") |>   addPolygons(     data = zipcode_population,     fillColor = ~ pal_zip(Overall), fillOpacity = .8, weight = 1,     color = \"#000\", highlightOptions = highlightOptions(color = \"#fff\"),     group = \"Block Groups -> Zip Codes\", label = ~ paste(       id, \"Population:\", round(Overall, 3)     )   ) |>   hideGroup(\"Block Groups -> Zip Codes\") |>   addPolygons(     data = bg_parcel_zipcode_population,     fillColor = ~ pal_zip(Overall), fillOpacity = .8, weight = 1,     color = \"#000\", highlightOptions = highlightOptions(color = \"#fff\"),     group = \"Block Groups -> Parcels -> Zip Codes\", label = ~ paste(       id, \"Population:\", round(Overall, 3)     )   ) |>   showGroup(\"Block Groups -> Parcels -> Zip Codes\") |>   addLegend(\"bottomright\", pal_zip, all_values, opacity = 1, title = \"Zip Codes\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Biocomplexity Institute. Copyright holder, funder. Micah Iserman. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Iserman M (2022). redistribute: Redistribute Data. R package version 0.0.1, https://github.com/uva-bi-sdad/redistribute.","code":"@Manual{,   title = {redistribute: Redistribute Data},   author = {Micah Iserman},   year = {2022},   note = {R package version 0.0.1},   url = {https://github.com/uva-bi-sdad/redistribute}, }"},{"path":"/index.html","id":"redistribute","dir":"","previous_headings":"","what":"Redistribute Data","title":"Redistribute Data","text":"R package redistribute data. data redistributed (source) observed given frame (across rows associated IDs). data redistributed new frames (target; different rows IDs mapped source). Generally, frames represent groupings, lowest-level frame contains single observations (e.g., individual, individual single time-point, time-point single source, etc.), highest-level frame single observation entire population. example, U.S. Census Bureau releases data different geolevels, county, tract, block group, increasingly lower-level (higher-resolution). represent different frames observations might redistributed. useful observations one frame, want observations another. Frames may also roughly level (similar observation-group sizes), arranged differently (e.g., group individuals along different dimensions). case, might best redistribute data lower-level frame, back higher-level frame.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Redistribute Data","text":"Download R r-project.org, install package R console: load package:","code":"# install.packages(\"remotes\") remotes::install_github(\"uva-bi-sdad/redistribute\") library(redistribute)"},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 redistribute authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/reference/redistribute.html","id":null,"dir":"Reference","previous_headings":"","what":"Redistribute Data — redistribute","title":"Redistribute Data — redistribute","text":"Distribute data source frame target frame.","code":""},{"path":"/reference/redistribute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Redistribute Data — redistribute","text":"","code":"redistribute(source, target = NULL, map = list(), source_id = \"GEOID\",   target_id = source_id, weight = NULL, source_variable = NULL,   source_value = NULL, aggregate = NULL, weight_agg_method = \"auto\",   outFile = NULL, overwrite = FALSE, make_intersect_map = FALSE,   overlaps = \"keep\", use_all = TRUE, return_geometry = TRUE,   return_map = FALSE, verbose = FALSE)"},{"path":"/reference/redistribute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Redistribute Data — redistribute","text":"source matrix-like object want distribute ; usually real complete dataset, often lower resolution / higher level. target matrix-like object want distribute : usually dataset want available, often higher resolution / lower level. map list entries named source IDs (aligning IDs), containing vectors associated target IDs (indices IDs). Entries can also numeric vectors IDs names, used weigh relationship. IDs related substrings (first characters target IDs source IDs), map can automatically generated . source target contain sf geometries, map made st_intersects (st_intersects(source, target)). intersects map made, source aggregated target, map entries contain multiple target IDs, entries weighted proportion overlap source area. source_id, target_id Name column source / target, vector containing IDs. source, default first column. target, columns searched one appears relate source IDs, falling back first column. weight Name column, vector containing weights (single value apply cases), apply target disaggregating, source aggregating. Defaults unit weights (weights 1). source_variable, source_value source tall (variables spread across rows rather columns), specifies names columns source containing variable names values conversion. aggregate Logical; specified, determine whether aggregate disaggregate source target. Otherwise, TRUE source observations target observations. weight_agg_method Means aggregating weight, case target IDs contain duplicates. Options \"sum\", \"average\", \"auto\" (default; sum weight integer-like, average otherwise). outFile Path CSV file save results. overwrite Logical; TRUE, overwrite existing outFile. make_intersect_map Logical; TRUE, opt calculate intersect-based map rather ID-based map, seem possible. specified FALSE, never calculate intersect-based map. overlaps specified TRUE \"keep\", assign target entities mapped multiple source entities single source entity. value determines entities weight assigned, \"first\" (default), \"last\", \"random\". use_all Logical; TRUE (default), redistribute map weights sum 1. Otherwise, entities may partially weighted. return_geometry Logical; FALSE, set returned data.frame's geometry target, exists. return_map Logical; TRUE, return map, without performing redistribution. Useful want inspect automatically created map, use later call. verbose Logical; TRUE, show status messages.","code":""},{"path":"/reference/redistribute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Redistribute Data — redistribute","text":"data.frame row target_ids (identified first column, id), column variable source.","code":""},{"path":"/reference/redistribute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Redistribute Data — redistribute","text":"","code":"# minimal example source <- c(a = 1, b = 2) target <- 1:5 (redistribute(source, target, verbose = TRUE)) #> ℹ source IDs: 1 #> ℹ target IDs: `target` vector #> ℹ map: all target IDs for single source #> ℹ weights: 1 #> ℹ disaggregating 2 variables: #> • (numb; 2) a, b #>   id   a   b #> 1  1 0.2 0.4 #> 2  2 0.2 0.4 #> 3  3 0.2 0.4 #> 4  4 0.2 0.4 #> 5  5 0.2 0.4  # multi-entity example source <- data.frame(id = c(\"a\", \"b\"), cat = c(\"aaa\", \"bbb\"), num = c(1, 2)) target <- data.frame(   id = sample(paste0(c(\"a\", \"b\"), rep(1:5, 2))),   population = sample.int(1e5, 10) ) (redistribute(source, target, verbose = TRUE)) #> ℹ source IDs: id column of `source` #> ℹ target IDs: id column of `target` #> ℹ map: first 1 character of target IDs #> ℹ weights: 1 #> ℹ disaggregating 2 variables: #> • (numb; 1) num #> • (char; 1) cat #> ℹ re-converting categorical levels #>    id cat num #> 1  b1 bbb 0.4 #> 2  a3 aaa 0.2 #> 3  a1 aaa 0.2 #> 4  a4 aaa 0.2 #> 5  b2 bbb 0.4 #> 6  a5 aaa 0.2 #> 7  b5 bbb 0.4 #> 8  b4 bbb 0.4 #> 9  b3 bbb 0.4 #> 10 a2 aaa 0.2"}]
